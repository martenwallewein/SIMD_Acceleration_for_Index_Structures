Presentation Notes:

- Title:
	- Vortrag über SIMD Acceleration for Index Structures
	- Betrachte ich verschiedene, aktuelle Index Strukturen und extrahiere Performancefaktoren für moderne Strukturen

- Gliederung:
	- Als erstes Motivation, warum ist das Thema wichtig
	- Danach ein Paar Grundlagen zu B+ Bäumen und der Anwendung von SIMD
	- Dann beschreibung der 4 betrachteten Index Strukturen, auf 2 im Detail eingehen, die anderen beiden nur kurz beschreiben
	- Evaluation der extrahierten PF und wie/ob die Index Strukturen diese umsetzen
	- Zum Schluss noch Conclusion: Was soll von dem Vortrag mitgenommen werden

- Motivation:
	- Warum ist das Thema wichtig:
	- In Datenbanken genutzte Index Strukturen schon sehr alt, wurden für disk-basierte Datenbanksysteme entwickelt
		-> Auch an diese angepasst, z.B. Knotengröße beim B-Baum passend zur Seitengröße des DBS
	- Das reicht nicht mehr für moderne Systeme
	- Datenmengen werden immer größer und somit auch Index Strukturen
	- In Memory Databases brauchen andere Anpassungen: IO Flaschenhals wandert von Platte <-> RAM zu RAM <-> Cache
	- Multiprozessoren immer gängiger, mehr Prozessorkerne
	- Erweiterte Prozessorfunktionalitäten wie SIMD zur Parallelisierung
	- Doch wie nutzt man diese am besten und welche Anpassungen sind nötig, um das Maximum an Performance aus der Index Struktur rauszuholen
	- Darauf will ich versuchen mit diesem Vortrag ein paar Antworten zu geben
	
- Excursion B+ Baum:
	- Nochmal kurz auf den B+ Baum eingehen:
	- B-Baum:
		- Ordnung m: Jeder knoten hat k, zwischen m und 2m, Schlüssel und k+1 Kinder
		-> Oder nur m Schlüssel? Nochmal in Datenbanken Implmementierungstechniken nachgucken
		- Wie Suche funktioniert...
	- B+ Baum:
		- B Baum, bei dem nur die Blätter schlüssel enthalten, inner Knoten nur referenzen auf Kindknoten
			-> Um Baumhöhe zu reduzieren
		- Blätter oft untereinander verlinkt, für Bereichssuche
		- 

- SIMD: 
	- Wie name schon sagt: eine Operation auf mehreren Daten parallel
		-> Man erhält dementsprechend je nach befehl mehrere Rückgabewerte
	- Prozessoren verfügen über extra SIMD befehle und register, die dies ermöglichen
	- Als Beispiel greater-than Vergleich für 4 signed 32 Bit integers
		-> Ergebnis wiederum der entsprechende Typ, kann mittels anderen befehlen umgewandelt werden
	- Im Gegensatz zu z.B. Pipelining tatsächliche Parallelität
	
- Adapted Index Structures:
	- Um zu evaluieren, welche Faktoren für moderne Index Strukturen wichtig sind, habe ich mir 4 herausgesucht und genauer untersucht
	- In meiner schriftlichen Ausarbeitung alle 4 detailliert beschrieben, hier aus Platzgründen nur 2 im Detail
	- Alle nochmal nennen?
	
- Seg-Tree/Trie:
	- Auch K-ärer Suchbaum genannt
		-> k-äre Suche: Wie Binäre Suche nur aufteilung des Raums in k Teile
		-> Folglich nur log_k Aufwand
	- Jeder Knoten ist in sich wieder in k-ärer Suchbaum 
	- Um die K-äre Suche durchzuführen, werden Knoten linearisiert, mittels Breitensuche bzw. Level-order Traversal
	- Der Parameter k wird anhand der Key-Größe und der SIMD Bandbreite ermittelt